# Generated By: Cursor (Claude Sonnet 4.5)
"""Core metrics utility functions for Prometheus integration."""

from __future__ import annotations

import os
import re
import socket
import time
from threading import Lock, Thread
from typing import Any, Callable

import prometheus_client

mutex = Lock()

gauges = {}  # type: dict[str, Any]
counters = {}  # type: dict[str, Any]
filesWatched = []  # type: list[str]

DEBUG = False


def sorted_keys(data: dict[str, Any] | None) -> list[str] | None:
    """Return sorted keys from dictionary."""
    if data is None or len(data.keys()) == 0:
        return None
    return sorted(data)


def sorted_values(data: dict[str, Any]) -> list[Any] | None:
    """Return values from dictionary in sorted key order."""
    keys = sorted_keys(data)
    if keys is None:
        return None
    values = []
    for key in keys:
        values.append(data[key])
    return values


def setDebug(value: bool) -> None:
    """Enable or disable debug logging."""
    global DEBUG
    DEBUG = value


def debug(message: str) -> None:
    """Print debug message if debug mode is enabled."""
    if DEBUG is True:
        print(message)


def enrichLabels(labelDict: dict[str, str] | None) -> dict[str, str] | None:
    """Add host label to label dictionary if not present."""
    if labelDict is None:
        return labelDict
    if "host" in labelDict:
        return labelDict
    host = socket.gethostname().lower()
    labelDict.update(
        {
            "host": host,
        }
    )
    return labelDict


def findNewestFile(directory: str, logfileregex: str) -> str | None:
    """Find the newest file matching regex that was modified in last 30 minutes."""
    now = time.time()
    filemtimes: dict[float, str] = {}
    for root, _, files in os.walk(directory, topdown=False):
        for name in files:
            m = re.match(logfileregex, name)
            if m is not None:
                filename = os.path.join(root, name)
                mtime = os.path.getmtime(filename)
                if mtime >= now - 30 * 60:
                    # file was modified in the last 30 minutes.  consider it. else ignore it.
                    filemtimes[mtime] = filename
    s = sorted(filemtimes.items())
    if len(s) == 0:
        return None
    return s[-1][1]


def watchFile(
    filename: str, frequencySeconds: float, callback: Callable[[str, str], None]
) -> None:
    """Watch a file and call callback for each new line."""
    try:
        if filename in filesWatched:
            print(f"Attempted create duplicate watchFile on: {filename}")
            return

        print(f"Creating watchFile on: {filename}")

        filesWatched.append(filename)
        with open(filename) as f:
            while True:
                line = f.readline()
                if not line:
                    time.sleep(frequencySeconds)
                else:
                    callback(filename, line)
    except Exception as e:
        # print the error in case it helps debug and remove the file from being tracked
        print(e)
        if filename in filesWatched:
            filesWatched.remove(filename)


def watchDirectory(logdir, logfileregex, frequencySeconds, callback):
    # type: (str, str, float, Callable[[str, str], None]) -> None
    """Watch directory for newest log file and start watching it."""
    while True:
        newestLogFile = findNewestFile(logdir, logfileregex)
        while newestLogFile is None or newestLogFile in filesWatched:
            time.sleep(frequencySeconds)
            newestLogFile = findNewestFile(logdir, logfileregex)

        # got a new log file, attempt to start watching it
        t = Thread(
            target=watchFile,
            args=(newestLogFile, frequencySeconds, callback),
            daemon=True,
        )
        t.start()


def getGauge(name: str, description: str, labelDict: list[str] | None) -> Any:
    """Get or create a Prometheus Gauge metric."""
    if name in gauges:
        gauge = gauges[name]
    else:
        with mutex:
            if name in gauges:
                gauge = gauges[name]
            else:
                print(f"Creating Gauge: {name}({labelDict})")
                label_names = labelDict if labelDict is not None else []
                gauge = prometheus_client.Gauge(name, description, label_names)
                gauges[name] = gauge
    return gauge


def getCounter(name: str, description: str, labelDict: list[str] | None) -> Any:
    """Get or create a Prometheus Counter metric."""
    if name in counters:
        counter = counters[name]
    else:
        with mutex:
            if name in counters:
                counter = counters[name]
            else:
                print(f"Creating Counter: {name}")
                label_names = labelDict if labelDict is not None else []
                counter = prometheus_client.Counter(name, description, label_names)
                counters[name] = counter
    return counter


def set(name: str, value: float | None, labelDict: dict[str, str]) -> None:
    """Set a Prometheus Gauge metric value."""
    enrichLabels(labelDict)
    gauge = getGauge(name, "", sorted_keys(labelDict))
    debug(f"metrics_utility.set({name}, {value}, {labelDict})")
    if len(labelDict.keys()) > 0:
        if value is not None:
            gauge.labels(*sorted_values(labelDict)).set(value)
        else:
            gauge.remove(*sorted_values(labelDict))
    else:
        # cannot clear value if there is no label, just let the error propogate up
        gauge.set(value)


def add(name: str, value: float | None, labelDict: dict[str, str]) -> None:
    """Increment a Prometheus Gauge metric by value."""
    enrichLabels(labelDict)
    gauge = getGauge(name, "", sorted_keys(labelDict))
    debug(f"metrics_utility.add({name}, {value}, {labelDict})")
    if len(labelDict.keys()) > 0:
        if value is not None:
            gauge.labels(*sorted_values(labelDict)).inc(value)
        else:
            gauge.remove(*sorted_values(labelDict))
    else:
        gauge.inc(value)


def inc(name: str, labelDict: dict[str, str]) -> None:
    """Increment a Prometheus Counter metric."""
    enrichLabels(labelDict)
    counter = getCounter(name, "", sorted_keys(labelDict))
    debug(f"metrics_utility.inc({name}, {labelDict})")
    if len(labelDict.keys()) > 0:
        counter.labels(*sorted_values(labelDict)).inc()
    else:
        counter.inc()


def dec(name: str, labelDict: dict[str, str]) -> None:
    """Decrement a Prometheus Gauge metric (uses Gauge, not Counter)."""
    enrichLabels(labelDict)
    # Note: Counters can't decrease in Prometheus, so we use a Gauge
    gauge = getGauge(name, "", sorted_keys(labelDict))
    debug(f"metrics_utility.dec({name}, {labelDict})")
    if len(labelDict.keys()) > 0:
        gauge.labels(*sorted_values(labelDict)).dec()
    else:
        gauge.dec()


def metrics(port: int) -> None:
    """Start Prometheus HTTP metrics server on specified port."""
    prometheus_client.start_http_server(port)
